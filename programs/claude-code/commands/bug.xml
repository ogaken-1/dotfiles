<?xml version="1.0" encoding="UTF-8"?>
<command>
  <purpose>エラーメッセージと異常な動作から根本原因を特定し、修正を行わずに事実に基づく分析を提供する。</purpose>
  <rules priority="critical">
    <rule>ファイルを変更、作成、削除しない</rule>
    <rule>修正を実装しない。提案のみを提供する</rule>
    <rule>ログ分析を主要な情報源として優先する</rule>
    <rule>ユーザーの推測ではなく事実から判断する</rule>
    <rule>ログを主要な情報源とする</rule>
  </rules>
  <rules priority="standard">
    <rule>デバッグ方法論にはinvestigation-patternsスキルを使用する</rule>
    <rule>調査をdebugエージェントに委任する</rule>
    <rule>原因を特定できない場合は正直に報告する</rule>
    <rule>近くの類似実装を確認する</rule>
    <rule>発生パスを時系列で追跡する</rule>
  </rules>
  <parallelization>
    <capability>
      <parallel_safe>true</parallel_safe>
      <read_only>true</read_only>
      <modifies_state>none</modifies_state>
    </capability>
    <execution_strategy>
      <max_parallel_agents>16</max_parallel_agents>
      <timeout_per_agent>180000</timeout_per_agent>
    </execution_strategy>
  </parallelization>
  <workflow>
    <phase name="analyze">
      <objective>エラータイプを分類し、調査範囲を確立する</objective>
      <step>1. これはどのタイプのエラーか？（構文、ランタイム、ロジック）</step>
      <step>2. どこで発生しているか？（ファイル、行、関数）</step>
      <step>3. どのログが利用可能か？</step>
      <step>4. エラーのコンテキストは何か？（前後、発生中）</step>
    </phase>
    <phase name="investigate">
      <objective>専門エージェントに並列調査を委任する</objective>
      <step>1. quality-assuranceエージェントに委任：スタックトレース、エラーパターンを分析する</step>
      <step>2. exploreエージェントに委任：エラー位置と関連するコードパスを発見する</step>
      <step>3. general-purposeエージェントに委任：ログと依存関係を分析する</step>
      <step>4. fact-checkエージェントに委任：エラーコンテキストで外部ドキュメント参照を検証する</step>
      <step>5. エージェントの発見からエラー位置の詳細を分析する</step>
      <step>6. 依存関係とインポートを確認する</step>
      <step>7. 設定ファイルと最近の変更を確認する</step>
    </phase>
    <reflection_checkpoint id="investigation_quality">
      <question>症状から原因までの完全な証拠チェーンを構築したか？</question>
      <question>具体的な証拠でエラーメカニズムを説明できるか？</question>
      <threshold>信頼度が70未満の場合、調査を継続するか不確実性をフラグする</threshold>
    </reflection_checkpoint>
    <phase name="gather">
      <objective>環境コンテキストとランタイム条件を収集する</objective>
      <step>1. ランタイム情報（OS、バージョン、環境変数）を収集する</step>
      <step>2. リソース（ディスク、メモリ、ネットワーク）を確認する</step>
    </phase>
    <reflection_checkpoint id="analysis_quality">
      <question>十分な証拠を収集したか？</question>
      <question>理解に不足がないか？</question>
      <threshold>信頼度が70未満の場合、さらに証拠を収集するかユーザーに確認する</threshold>
    </reflection_checkpoint>
    <phase name="failure_handling">
      <objective>調査失敗を適切に処理する</objective>
      <step>1. ツール呼び出しが失敗した場合：エラーをログに記録し、代替アプローチを試行する</step>
      <step>2. データが利用できない場合：ギャップを文書化し、部分的な分析で続行する</step>
      <step>3. 矛盾する証拠がある場合：不確実性をフラグし、ユーザーに確認を求める</step>
    </phase>
    <phase name="report">
      <objective>発見を実行可能な根本原因分析に統合する</objective>
      <step>1. 信頼度メトリクスを用いてエージェントの発見を集約する</step>
      <step>2. 裏付けとなる証拠とともに根本原因を特定する</step>
    </phase>
    <phase name="self_evaluate">
      <objective>調査出力の簡潔な品質評価</objective>
      <step>1. decision_criteriaを使用して信頼度を計算：root_cause_certainty（50%）、evidence_chain（30%）、fix_viability（20%）</step>
      <step>2. 信頼度が80未満または証拠ギャップが検出された場合、上位1-2個の重大な問題を特定する</step>
      <step>3. 出力にself_feedbackセクションを追加する</step>
    </phase>
  </workflow>
  <decision_criteria>
    <criterion name="confidence_calculation">
      <factor name="root_cause_certainty" weight="0.5">
        <score range="90-100">再現により根本原因を確認</score>
        <score range="70-89">可能性の高い根本原因を特定</score>
        <score range="50-69">考えられる原因を特定</score>
        <score range="0-49">根本原因が不明</score>
      </factor>
      <factor name="evidence_chain" weight="0.3">
        <score range="90-100">症状から原因までの完全な証拠チェーン</score>
        <score range="70-89">強い証拠の連鎖</score>
        <score range="50-69">部分的な証拠</score>
        <score range="0-49">弱い証拠</score>
      </factor>
      <factor name="fix_viability" weight="0.2">
        <score range="90-100">明確でテスト済みの修正が利用可能</score>
        <score range="70-89">修正アプローチが定義済み</score>
        <score range="50-69">可能な修正を特定</score>
        <score range="0-49">明確な修正なし</score>
      </factor>
    </criterion>
    <validation_tests>
      <test name="confirmed_root_cause">
        <input>root_cause_certainty=95, evidence_chain=90, fix_viability=95</input>
        <calculation>(95*0.5)+(90*0.3)+(95*0.2) = 47.5+27+19 = 93.5</calculation>
        <expected_status>success</expected_status>
        <reasoning>テスト済み修正を伴う再現された根本原因は高い信頼度をもたらす</reasoning>
      </test>
      <test name="boundary_warning_79">
        <input>root_cause_certainty=80, evidence_chain=75, fix_viability=80</input>
        <calculation>(80*0.5)+(75*0.3)+(80*0.2) = 40+22.5+16 = 78.5</calculation>
        <expected_status>warning</expected_status>
        <reasoning>完全な証拠なしの可能性の高い原因は78.5となり警告をトリガー</reasoning>
      </test>
      <test name="boundary_success_80">
        <input>root_cause_certainty=85, evidence_chain=75, fix_viability=75</input>
        <calculation>(85*0.5)+(75*0.3)+(75*0.2) = 42.5+22.5+15 = 80</calculation>
        <expected_status>success</expected_status>
        <reasoning>加重平均がちょうど80、成功閾値を満たす</reasoning>
      </test>
      <test name="boundary_error_59">
        <input>root_cause_certainty=60, evidence_chain=55, fix_viability=60</input>
        <calculation>(60*0.5)+(55*0.3)+(60*0.2) = 30+16.5+12 = 58.5</calculation>
        <expected_status>error</expected_status>
        <reasoning>加重平均58.5は60未満でエラーをトリガー</reasoning>
      </test>
      <test name="unclear_cause">
        <input>root_cause_certainty=45, evidence_chain=50, fix_viability=40</input>
        <calculation>(45*0.5)+(50*0.3)+(40\*0.2) = 22.5+15+8 = 45.5</calculation>
        <expected_status>error</expected_status>
        <reasoning>弱い証拠を伴う不明確な根本原因は45.5となりエラーをトリガー</reasoning>
      </test>
    </validation_tests>
  </decision_criteria>
  <agents>
    <agent name="quality-assurance" subagent_type="quality-assurance" readonly="true">エラー追跡、スタックトレース分析、デバッグ</agent>
    <agent name="general-purpose" subagent_type="general-purpose" readonly="true">ログ分析、可観測性、依存関係エラー</agent>
    <agent name="explore" subagent_type="explore" readonly="true">エラー位置の発見、関連するコードパス</agent>
    <agent name="fact-check" subagent_type="fact-check" readonly="true">ライブラリ、ドキュメント、標準を参照する主張の外部ソース検証</agent>
  </agents>
  <execution_graph>
    <parallel_group id="error_analysis" depends_on="none">
      <agent>quality-assurance</agent>
      <agent>explore</agent>
      <agent>fact-check</agent>
    </parallel_group>
    <parallel_group id="context_gathering" depends_on="none">
      <agent>general-purpose</agent>
    </parallel_group>
    <sequential_phase id="synthesis" depends_on="error_analysis,context_gathering">
      <agent>quality-assurance</agent>
      <reason>エラー分析とコンテキスト収集の両方からの発見が必要</reason>
    </sequential_phase>
  </execution_graph>
  <delegation>
    <requirement>完全なエラーメッセージ/スタックトレース</requirement>
    <requirement>再現手順（分かっている場合）</requirement>
    <requirement>関連するファイルパス</requirement>
    <requirement>明示的な編集禁止</requirement>
  </delegation>
  <output>
    <format>
      <overview>エラーと調査の概要</overview>
      <log_analysis>重要なログ情報、エラーコンテキスト</log_analysis>
      <code_analysis>関連コード、特定された問題</code_analysis>
      <root_cause>
- 直接的な原因
- 根本的な原因
- 条件</root_cause>
      <metrics>
- 信頼度：0-100
- ログ活用度：0-100
- 客観性：0-100</metrics>
      <impact>影響範囲、類似エラー</impact>
      <recommendations>修正提案（実装なし）、予防策</recommendations>
      <further_investigation>不明点、次のステップ</further_investigation>
      <self_feedback>
        <confidence>XX/100（root_cause_certaintyに基づく）</confidence>
        <issues>
- [Critical] 問題の説明（もしあれば、最大2つ）
- [Warning] 問題の説明（もしあれば）
      </issues>
      </self_feedback>
    </format>
  </output>
  <enforcement>
    <mandatory_behaviors>
      <behavior id="BUG-B001" priority="critical">
        <trigger>根本原因を結論付ける前</trigger>
        <action>症状から原因までの証拠チェーンを構築する</action>
        <verification>出力に証拠チェーンを含める</verification>
      </behavior>
      <behavior id="BUG-B002" priority="critical">
        <trigger>修正を提案する場合</trigger>
        <action>影響を受けるすべてのコードパスを特定する</action>
        <verification>出力に影響分析を含める</verification>
      </behavior>
    </mandatory_behaviors>
    <prohibited_behaviors>
      <behavior id="BUG-P001" priority="critical">
        <trigger>常に</trigger>
        <action>証拠なしに結論付ける</action>
        <response>結論をブロックし、調査を要求する</response>
      </behavior>
    </prohibited_behaviors>
  </enforcement>
  <error_escalation>
    <level severity="low">
      <example>影響のない軽微なログ警告</example>
      <action>レポートに記録し、続行する</action>
    </level>
    <level severity="medium">
      <example>不明確なエラーコンテキストまたは欠落したスタックトレース</example>
      <action>問題を文書化し、AskUserQuestionを使用して確認する</action>
    </level>
    <level severity="high">
      <example>システムクラッシュまたはデータ破損が検出された</example>
      <action>停止し、ユーザーに選択肢を提示する</action>
    </level>
    <level severity="critical">
      <example>セキュリティ侵害または重大なデータ損失のリスク</example>
      <action>操作をブロックし、ユーザーの明示的な承認を要求する</action>
    </level>
  </error_escalation>
  <related_commands>
    <command name="ask">調査でアーキテクチャに関する質問が発生した場合</command>
    <command name="define">バグ修正に要件定義が必要な場合</command>
    <command name="execute">調査後に修正を実装する準備ができた場合</command>
  </related_commands>
  <related_skills>
    <skill name="investigation-patterns">コアデバッグ方法論</skill>
    <skill name="serena-usage">効率的にエラー位置をナビゲートする</skill>
    <skill name="testing-patterns">テスト失敗とカバレッジギャップを理解する</skill>
    <skill name="fact-check">Context7とWebSearchを使用した外部ソース検証</skill>
  </related_skills>
  <constraints>
    <must>すべての操作を読み取り専用に保つ</must>
    <must>ログを主要な情報源として優先する</must>
    <must>原因を特定できない場合は正直に報告する</must>
    <avoid>修正を実装する</avoid>
    <avoid>検証なしにユーザーの推測を受け入れる</avoid>
    <avoid>証拠が不十分な場合に無理やり原因を作り上げる</avoid>
  </constraints>
</command>
