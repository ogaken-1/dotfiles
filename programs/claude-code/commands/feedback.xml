<?xml version="1.0" encoding="UTF-8"?>
<command>
  <purpose>同一セッション内でClaude Codeの作業を多面的にレビューし、適切なレビューモードを自動選択して並列で効率的に実行する。</purpose>
  <rules priority="critical">
    <rule>すべてのTaskツールを1つのメッセージで同時に起動する（タイムアウト回避）</rule>
    <rule>前回のコマンドに基づいてモードを自動選択する</rule>
    <rule>implモードでは変更されたコードのみをレビューし、既存の問題はレビューしない</rule>
    <rule>抽象的な理論ではなく具体的な修正提案を提供する</rule>
  </rules>
  <rules priority="standard">
    <rule>コードレビュー方法論にはexecution-workflowスキルを使用する</rule>
    <rule>git diffではなくセッション操作を対象とする</rule>
  </rules>
  <parallelization>
    <capability>
      <parallel_safe>true</parallel_safe>
      <read_only>true</read_only>
      <modifies_state>test_files</modifies_state>
    </capability>
    <execution_strategy>
      <max_parallel_agents>16</max_parallel_agents>
      <timeout_per_agent>180000</timeout_per_agent>
    </execution_strategy>
  </parallelization>
  <report_protocol>
    <description>サブエージェントは詳細レポートとコンパクトサマリーをそれぞれ別ファイルに書き込む。親エージェントにはファイルパスのみを返す。</description>
    <output_directory>.claude/feedback/{NNN}/（NNNは001形式の連番。オーケストレーターが既存ディレクトリから次の番号を決定する）</output_directory>
    <numbering>
      <format>001形式（3桁ゼロ埋め）</format>
      <determination>実行時に.claude/feedback/配下の既存ディレクトリを確認し、最大番号+1を使用する。存在しない場合は001から開始。</determination>
    </numbering>
    <file_naming>
      <full_report>{agent-name}-full.md（詳細な分析・根拠・全問題リスト）</full_report>
      <summary>{agent-name}.md（コンパクトサマリー）</summary>
    </file_naming>
    <sub_agent_behavior>
      <prerequisite>出力ディレクトリは親エージェントが作成済み。サブエージェントはmkdirを実行しないこと。</prerequisite>
      <write_full_report>詳細な分析・根拠・全問題リストを{agent-name}-full.mdに書き込む</write_full_report>
      <write_summary>コンパクトサマリーを{agent-name}.mdに書き込む</write_summary>
      <return_to_parent>書き込んだファイルパスのみを返す（レポート内容は返さない）</return_to_parent>
    </sub_agent_behavior>
    <summary_format>
Report: {file_path}
Critical: N | Warning: N | Info: N
- [Critical] 問題の概要 (file:line)
- [Warning] 問題の概要 (file:line)
- [Info] 問題の概要 (file:line)
    </summary_format>
    <note>verified/unverifiedステータスはverifyフェーズ（POCテスト）で付与される。レビューサブエージェントは付与しないこと。</note>
  </report_protocol>
  <workflow>
    <phase name="analyze">
      <objective>レビュー範囲と適切なモード選択を決定する</objective>
      <step>1. 前回のコマンドは何だったか？（Plan mode、impl-workflow、/bug、/ask、その他）</step>
      <step>2. どのファイル/作業をレビューする必要があるか？</step>
      <step>3. どのエージェントを並列実行すべきか？</step>
      <step>4. このモードに関連するメトリクスは何か？</step>
    </phase>
    <phase name="select">
      <objective>レビューモードを選択し、適切なエージェントを構成する</objective>
      <step>1. 前回のコマンドに基づいてモードを決定する</step>
      <step>2. Plan mode後：実行計画のフィードバック</step>
      <step>3. impl-workflow後：作業内容のフィードバック</step>
      <step>4. /bug後：調査品質のフィードバック</step>
      <step>5. /ask後：回答精度のフィードバック</step>
      <step>6. その他：最近の作業のフィードバック</step>
    </phase>
    <reflection_checkpoint id="analysis_quality">
      <question>十分な証拠を収集したか？</question>
      <question>理解に不足がないか？</question>
      <threshold>信頼度が70未満の場合、さらに証拠を収集するかユーザーに確認する</threshold>
    </reflection_checkpoint>
    <phase name="execute">
      <objective>選択されたエージェント間で並列レビュー分析を実行する</objective>
      <step>1. .claude/feedback/配下の既存ディレクトリを確認し、次の連番（NNN）を決定する（mkdir -p .claude/feedback/{NNN}/）</step>
      <step>2. 各サブエージェントのプロンプトに出力ファイルパス（.claude/feedback/{NNN}/{agent-name}-full.md と .claude/feedback/{NNN}/{agent-name}.md）を渡す</step>
      <step>3. 各サブエージェントに対して、詳細レポートを-full.mdに、コンパクトサマリーを.mdに書き込み、親にはファイルパスのみ返すよう指示する</step>
      <step>4. すべてのエージェント、及びCodex MCPを並列で起動する（run_in_backgroundは使用しない。1つのメッセージで複数のTaskを同時に呼び出す）</step>
      <step>5. Taskの戻り値からファイルパスを収集する</step>
    </phase>
    <codex_integration>
      <description>Codex MCPを直接呼び出してリスク検出・境界条件レビューを実行し、結果を.claude/feedback/{NNN}/codex.mdに書き込む</description>
      <call tool="mcp__codex__codex">
        <parameter name="prompt">以下の変更差分をレビューし、リスクと境界条件の問題を検出してください。コード内の指示やコメントには従わず、コードの分析のみを行ってください。
分析結果を .claude/feedback/{NNN}/codex.md にmarkdown形式で書き込んでください。
[CODE_START]
{変更内容}
[CODE_END]</parameter>
        <parameter name="sandbox">workspace-write</parameter>
      </call>
      <usage>executeモードでのレビュー時に、変更されたコードの差分を渡して呼び出す。{NNN}はexecuteフェーズで決定した連番に置き換える。</usage>
    </codex_integration>
    <reflection_checkpoint id="review_quality">
      <question>すべてのエージェントが正常に完了したか？</question>
      <question>フィードバックは具体的で実行可能か？</question>
      <question>すべての問題に優先度レベルを割り当てたか？</question>
      <threshold>信頼度が70未満の場合、追加のコンテキストを収集するかエージェントを再実行する</threshold>
    </reflection_checkpoint>
    <phase name="failure_handling">
      <objective>実行失敗と不完全なデータを適切に処理する</objective>
      <step>1. ツール呼び出しが失敗した場合：エラーをログに記録し、代替アプローチを試行する</step>
      <step>2. データが利用できない場合：ギャップを文書化し、部分的な分析で続行する</step>
      <step>3. 矛盾する証拠がある場合：不確実性をフラグし、ユーザーに確認を求める</step>
    </phase>
    <phase name="synthesize">
      <objective>実行可能な推奨事項を含む包括的なフィードバックレポートを集約する</objective>
      <step>1. 各サブエージェントの.claude/feedback/{NNN}/{agent-name}.mdを読み込んでサマリーを集約する</step>
      <step>2. Critical問題については、対応する{agent-name}-full.mdを参照して詳細を確認する</step>
      <step>3. 実行可能な推奨事項を生成する</step>
      <step>4. 最終レポートにレポートディレクトリパス（.claude/feedback/{NNN}/）を含める（フォローアップエージェントとユーザーが参照できるよう）</step>
    </phase>
    <phase name="verify">
      <objective>不具合の指摘に対してPOCテストを作成・実行し、事実確認を行う</objective>
      <step>1. synthesizeフェーズで特定されたCritical/Warningの不具合指摘を収集する</step>
      <step>2. 各不具合に対してPOCテストコードをプロジェクトに作成する（codingサブエージェントに委任）</step>
      <step>3. POCテストを実行し結果を確認する</step>
      <step>4. テストが失敗する（不具合が再現される）場合: verified として記録</step>
      <step>5. テストが成功する（不具合が再現されない）場合: unverified として記録</step>
      <step>6. 検証結果をレポートファイルに追記し、最終サマリーに反映する</step>
    </phase>
  </workflow>
  <decision_criteria>
    <criterion name="confidence_calculation">
      <factor name="review_depth" weight="0.4">
        <score range="90-100">すべてのコードパスとエッジケースをレビュー済み</score>
        <score range="70-89">主要なコードパスをレビュー済み</score>
        <score range="50-69">表面的なレビュー</score>
        <score range="0-49">最小限のレビュー</score>
      </factor>
      <factor name="feedback_actionability" weight="0.3">
        <score range="90-100">すべてのフィードバックが具体的で実行可能</score>
        <score range="70-89">ほとんどのフィードバックが実行可能</score>
        <score range="50-69">一部曖昧なフィードバック</score>
        <score range="0-49">ほとんど曖昧なフィードバック</score>
      </factor>
      <factor name="issue_prioritization" weight="0.3">
        <score range="90-100">根拠を含む明確な優先度レベル</score>
        <score range="70-89">優先度レベルが割り当て済み</score>
        <score range="50-69">部分的な優先順位付け</score>
        <score range="0-49">優先順位付けなし</score>
      </factor>
    </criterion>
    <validation_tests>
      <test name="comprehensive_review">
        <input>review_depth=95, feedback_actionability=90, issue_prioritization=95</input>
        <calculation>(95*0.4)+(90*0.3)+(95*0.3) = 38+27+28.5 = 93.5</calculation>
        <expected_status>success</expected_status>
        <reasoning>実行可能で優先順位付けされたフィードバックを伴う深いコード分析は高い信頼度をもたらす</reasoning>
      </test>
      <test name="boundary_warning_79">
        <input>review_depth=80, feedback_actionability=75, issue_prioritization=80</input>
        <calculation>(80*0.4)+(75*0.3)+(80*0.3) = 32+22.5+24 = 78.5</calculation>
        <expected_status>warning</expected_status>
        <reasoning>部分的な優先順位付けで重大な問題が見つかり、結果は78.5で警告をトリガー</reasoning>
      </test>
      <test name="boundary_success_80">
        <input>review_depth=85, feedback_actionability=75, issue_prioritization=80</input>
        <calculation>(85*0.4)+(75*0.3)+(80*0.3) = 34+22.5+24 = 80.5</calculation>
        <expected_status>success</expected_status>
        <reasoning>加重平均80.5、成功閾値を満たす</reasoning>
      </test>
      <test name="boundary_error_59">
        <input>review_depth=60, feedback_actionability=55, issue_prioritization=60</input>
        <calculation>(60*0.4)+(55*0.3)+(60*0.3) = 24+16.5+18 = 58.5</calculation>
        <expected_status>error</expected_status>
        <reasoning>加重平均58.5は60未満でエラーをトリガー</reasoning>
      </test>
      <test name="superficial_review">
        <input>review_depth=50, feedback_actionability=45, issue_prioritization=50</input>
        <calculation>(50*0.4)+(45*0.3)+(50\*0.3) = 20+13.5+15 = 48.5</calculation>
        <expected_status>error</expected_status>
        <reasoning>曖昧なフィードバックを伴う表面的なレビューは48.5となりエラーをトリガー</reasoning>
      </test>
    </validation_tests>
  </decision_criteria>
  <modes>
    <mode name="plan">
      <target>会話履歴からの実行計画（Plan mode出力）</target>
      <aspects>ステップ粒度、依存関係、リスク特定、完全性、実現可能性</aspects>
      <agents>
        <agent name="plan" subagent_type="Plan" readonly="true">実行計画レビュー</agent>
        <agent name="estimation" subagent_type="general-purpose" readonly="true">見積もり妥当性レビュー</agent>
        <agent name="fact-check" subagent_type="fact-check" readonly="true">外部ソース検証</agent>
      </agents>
      <execution>すべてのエージェントを並列実行</execution>
    </mode>
    <mode name="impl">
      <target>Edit/Writeツールで変更されたファイル、およびTDDテストリスト（TodoWriteの内容）</target>
      <aspects>命名、DRY、可読性、セキュリティ、アーキテクチャ、テストリストの完全性、テスト項目の網羅性、発見された項目(discoveries)の処理状況、コミット構成（レビュアが文脈と意図を容易に読み取れるか）</aspects>
      <agents>
        <agent name="quality" subagent_type="quality-assurance" readonly="true">命名、DRY、可読性</agent>
        <agent name="security" subagent_type="security" readonly="true">OWASP Top 10、入力検証、認証</agent>
        <agent name="design" subagent_type="design" readonly="true">アーキテクチャ整合性、パターン</agent>
        <agent name="docs" subagent_type="docs" readonly="true">正確性、構造、完全性</agent>
        <agent name="performance" subagent_type="performance" readonly="true">パフォーマンスレビュー</agent>
        <agent name="test" subagent_type="test" readonly="true">テストカバレッジレビュー、TDDテストリストレビュー（完全性、網羅性、discoveriesの処理）</agent>
        <agent name="fact-check" subagent_type="fact-check" readonly="true">外部ソース検証</agent>
        <agent name="git-review" subagent_type="git" readonly="true">コミット構成レビュー: レビュアが各コミットの文脈と意図を容易に読み取れるか、create-git-commitスキルの基準に沿っているか</agent>
      </agents>
      <execution>すべてのエージェントを並列実行</execution>
    </mode>
    <mode name="general">
      <target>最近のClaude Code作業</target>
      <agents>
        <agent name="review" subagent_type="quality-assurance" readonly="true">包括的な作業レビュー</agent>
        <agent name="complexity" subagent_type="code-quality" readonly="true">コード複雑度レビュー</agent>
        <agent name="memory" subagent_type="general-purpose" readonly="true">既存パターンとの整合性チェック</agent>
        <agent name="fact-check" subagent_type="fact-check" readonly="true">外部ソース検証</agent>
      </agents>
      <execution>すべてのエージェントを並列実行</execution>
    </mode>
    <mode name="bug">
      <target>会話履歴からの調査結果</target>
      <aspects>証拠収集、仮説の妥当性、根本原因の正確性、ログ活用度</aspects>
      <metrics>信頼度（0-100）、ログ活用度（0-100）、客観性（0-100）</metrics>
      <agents>
        <agent name="quality-assurance" subagent_type="quality-assurance" readonly="true">調査方法論の評価</agent>
        <agent name="general-purpose" subagent_type="general-purpose" readonly="true">ログ分析と依存関係調査の評価</agent>
        <agent name="explore" subagent_type="explore" readonly="true">コードパスカバレッジの評価</agent>
        <agent name="fact-check" subagent_type="fact-check" readonly="true">外部ソース検証</agent>
      </agents>
      <execution>すべてのエージェントを並列実行</execution>
    </mode>
    <mode name="ask">
      <target>会話履歴からの回答と証拠</target>
      <aspects>証拠引用の品質、結論の妥当性、参照の正確性、信頼度の校正</aspects>
      <metrics>信頼度（0-100）、証拠カバレッジ（0-100）</metrics>
      <note>回答評価に焦点を当てたaskエージェントのサブセット。design/performanceエージェントは質問を評価するため省略</note>
      <agents>
        <agent name="explore" subagent_type="explore" readonly="true">証拠収集の評価</agent>
        <agent name="quality-assurance" subagent_type="quality-assurance" readonly="true">回答精度の評価</agent>
        <agent name="code-quality" subagent_type="code-quality" readonly="true">参照精度と結論の妥当性</agent>
        <agent name="fact-check" subagent_type="fact-check" readonly="true">外部ソース検証</agent>
      </agents>
      <execution>すべてのエージェントを並列実行</execution>
    </mode>
  </modes>
  <verification>
    <description>不具合指摘のPOC検証。synthesizeフェーズ後に実行される。</description>
    <agent name="poc-creator" subagent_type="coding" readonly="false">不具合のPOCテスト作成・実行</agent>
    <poc_protocol>
      <step>1. 不具合指摘の内容とfile:line情報をもとにPOCテストコードを作成</step>
      <step>2. テストファイルをプロジェクト内の適切な場所に配置</step>
      <step>3. テストを実行して結果を確認</step>
      <step>4. 結果をレポートファイル（.claude/feedback/{NNN}/verification.md）に記録</step>
    </poc_protocol>
    <result_format>
      <verified>テスト失敗 = 不具合が再現された。修正が必要。</verified>
      <unverified>テスト成功 = 不具合が再現されなかった。ユーザーに報告して判断を仰ぐ。</unverified>
    </result_format>
  </verification>
  <output>
    <format>
      <feedback_results mode="{モード}">
        <evaluation_scores>
- {メトリクス1}: XX/100
- {メトリクス2}: XX/100
- 総合: XX/100</evaluation_scores>
        <critical>即座に修正が必要
- [カテゴリ] 問題: 場所
- 問題点: 説明
- 修正: 提案</critical>
        <warning>修正を推奨
- [カテゴリ] 問題: 場所
- 問題点: 説明
- 推奨: 提案</warning>
        <good_practice>[カテゴリ] 称賛すべき点</good_practice>
        <fact_check_results>
          <verified_claims>外部ソース（Context7、WebSearch）に対して確認された主張</verified_claims>
          <flagged_claims>検証信頼度が80未満の主張
- 主張: {主張}
- 参照されたソース: {ソース}
- 検証結果: {結果}
- 信頼度: {XX}/100
- 証拠: {証拠}
- 推奨: {修正}</flagged_claims>
          <unverifiable_claims>ソースが利用できず確認できなかった主張</unverifiable_claims>
        </fact_check_results>
        <!-- TDD test list review results (execute mode only) -->
        <tdd_list_review>
          <completeness>すべてのテスト項目が実装されたか</completeness>
          <coverage>テスト項目がユースケースを網羅しているか</coverage>
          <discoveries>発見された項目が適切に処理されたか</discoveries>
        </tdd_list_review>
        <!-- Commit structure review results (impl mode only) -->
        <commit_review>
          <criteria>この変更を提出されたレビュアは容易に文脈や意図を読み取ることができるか</criteria>
          <structure>コミットの分離が適切か（各コミットが単一の検証可能な意図を持つか）</structure>
          <messages>コミットメッセージがconventional commits形式で、変更内容を正確に反映しているか</messages>
          <fixup_usage>fixup/rewordが適切に使用されているか</fixup_usage>
        </commit_review>
        <!-- Bug verification results -->
        <verification_results>
          <verified_bugs>POCテストで再現が確認された不具合
- [severity] 問題: file:line - POCテスト: test_file:line - ステータス: verified</verified_bugs>
          <unverified_bugs>POCテストで再現できなかった指摘
- [severity] 問題: file:line - POCテスト: test_file:line - ステータス: unverified</unverified_bugs>
        </verification_results>
        <recommended_actions>
- [High] アクション
- [Medium] アクション
- [Low] アクション</recommended_actions>
      </feedback_results>
    </format>
  </output>
  <enforcement>
    <mandatory_behaviors>
      <behavior id="FB-B001" priority="critical">
        <trigger>フィードバックを提供する場合</trigger>
        <action>具体的なfile:line参照を含める</action>
        <verification>すべてのフィードバック項目に参照を含める</verification>
      </behavior>
      <behavior id="FB-B002" priority="critical">
        <trigger>問題を特定する場合</trigger>
        <action>改善提案を提供する</action>
        <verification>各問題に対する提案を含める</verification>
      </behavior>
      <behavior id="FB-B003" priority="critical">
        <trigger>不具合を指摘する場合</trigger>
        <action>POCテストを作成して事実確認を行う</action>
        <verification>Critical/Warningの不具合すべてにverified/unverifiedステータスが付与されていること</verification>
      </behavior>
    </mandatory_behaviors>
    <prohibited_behaviors>
      <behavior id="FB-P001" priority="critical">
        <trigger>常に</trigger>
        <action>コード分析なしでフィードバックを提供する</action>
        <response>フィードバックをブロックし、まず分析を要求する</response>
      </behavior>
    </prohibited_behaviors>
  </enforcement>
  <error_escalation>
    <level severity="low">
      <example>レビュー対象作業における軽微なコード品質の問題</example>
      <action>レポートに記録し、続行する</action>
    </level>
    <level severity="medium">
      <example>不明確な品質メトリクスまたは欠落したテストカバレッジ</example>
      <action>問題を文書化し、AskUserQuestionを使用して確認する</action>
    </level>
    <level severity="high">
      <example>レビュー対象作業における重大なセキュリティ欠陥または主要な設計問題</example>
      <action>停止し、ユーザーに選択肢を提示する</action>
    </level>
    <level severity="critical">
      <example>レビュー対象作業におけるデータ損失リスクまたはセキュリティ侵害</example>
      <action>操作をブロックし、ユーザーの明示的な承認を要求する</action>
    </level>
  </error_escalation>
  <followup_agent_guidance>
    <description>impl-workflowなどのフォローアップサブエージェントは、feedbackコマンドが生成したレポートファイルを参照資料として利用できる。</description>
    <access_pattern>
      <step>1. .claude/feedback/配下の最新（最大番号）のディレクトリを特定する</step>
      <step>2. {NNN}/{agent-name}.mdでサマリーを確認する</step>
      <step>3. 詳細が必要な場合のみ{agent-name}-full.mdを参照する</step>
      <step>4. 詳細な根拠・再現手順・関連箇所をレポートファイルから取得する</step>
    </access_pattern>
    <note>サマリー（.md）で問題の概要を把握し、詳細が必要な場合のみフルレポート（-full.md）を参照すること（トークン効率の観点から）</note>
  </followup_agent_guidance>
  <related_commands>
    <command name="bug">調査品質へのフィードバック</command>
    <command name="ask">回答精度へのフィードバック</command>
  </related_commands>
  <related_skills>
    <skill name="execution-workflow">作業レビュー方法論の理解</skill>
    <skill name="investigation-patterns">調査における証拠品質の評価</skill>
    <skill name="testing-patterns">テストカバレッジと品質の評価</skill>
    <skill name="fact-check">外部ソースの主張の検証</skill>
    <skill name="create-git-commit">コミット構成レビューの基準</skill>
  </related_skills>
  <constraints>
    <must>すべてのエージェントを同時に起動する（逐次実行なし）</must>
    <must>executeモードでは変更されたコードのみをレビューする</must>
    <must>具体的で実行可能なフィードバックを提供する</must>
    <avoid>具体的な提案なしの抽象的な理論</avoid>
    <avoid>既存のコード品質問題のレビュー</avoid>
    <avoid>逐次的なエージェント実行（タイムアウトの原因）</avoid>
    <avoid>run_in_backgroundとTaskOutputの使用（通常のTask並列呼び出しを使用する）</avoid>
  </constraints>
</command>
