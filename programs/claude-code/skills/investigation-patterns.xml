<?xml version="1.0" encoding="UTF-8"?>
<skill>
  <purpose>適切な信頼度評価を伴う証拠に基づく分析を確保する、コードベース調査とデバッグの体系的なパターンを提供する。</purpose>
  <rules priority="critical">
    <rule>すべての発見事項にpath/to/file.ext:line_number形式でfile:line参照を常に提供</rule>
    <rule>すべての調査結果に信頼度とカバレッジのメトリクスを評価</rule>
    <rule>解決策を提案する前に調査を完了</rule>
  </rules>
  <rules priority="standard">
    <rule>ファイル全体を読む前にSerenaシンボルツールを使用</rule>
    <rule>仮定を確認するのではなく、主張を独立して検証</rule>
    <rule>情報のギャップと不明確な点を文書化</rule>
    <rule>信頼度を高めるために複数のソースを確認</rule>
    <rule>体系的なデバッグフェーズを使用（再現、分離、調査、仮説、修正）</rule>
  </rules>
  <patterns>
    <pattern name="scope_classification">
      <description>調査アプローチを決定するために質問タイプを分類</description>
      <decision_tree name="when_to_use">
        <question>質問はコードベースの構造または動作の理解を必要としますか？</question>
        <if_yes>調査の深さとツールを決定するためにスコープ分類を適用</if_yes>
        <if_no>不明確な要件には要件定義スキルを検討</if_no>
      </decision_tree>
      <example>
        アーキテクチャ: システム設計、コンポーネント関係
        実装: 特定のコード動作、アルゴリズム詳細
        デバッグ: エラー原因、予期しない動作
        設計: パターン使用、コード構成
      </example>
    </pattern>
    <pattern name="source_identification">
      <description>調査のための関連ソースを特定</description>
      <decision_tree name="when_to_use">
        <question>コードベースは大規模または馴染みがないですか？</question>
        <if_yes>関連する証拠を効率的に特定するためにソース特定を適用</if_yes>
        <if_no>既知のソースを直接調査</if_no>
      </decision_tree>
      <example>
        コード: シンボル検索と依存関係分析にSerenaを使用
        ドキュメント: インラインコメント、README、APIドキュメントを確認
        履歴: 変更のコンテキストのためにGitログを確認
        外部: ライブラリドキュメントにContext7を使用
      </example>
    </pattern>
    <pattern name="evidence_collection">
      <description>適切なツールを使用して体系的に証拠を収集</description>
      <decision_tree name="when_to_use">
        <question>調査する特定のシンボルまたはパターンがありますか？</question>
        <if_yes>シンボルレベルツールで証拠収集を適用</if_yes>
        <if_no>関連する領域を特定するためにソース特定から開始</if_no>
      </decision_tree>
      <example>
        mcp__serena__find_symbol: 名前で特定のシンボルを検索
        mcp__serena__get_symbols_overview: ファイル構造を理解
        mcp__serena__find_referencing_symbols: 依存関係を追跡
        mcp__serena__search_for_pattern: コードベース全体でパターンを検索
      </example>
    </pattern>
    <pattern name="synthesis">
      <description>信頼度メトリクスとともに発見事項を統合</description>
      <decision_tree name="when_to_use">
        <question>複数のソースから十分な証拠を収集しましたか？</question>
        <if_yes>信頼度メトリクスとともに発見事項を組み合わせるために統合を適用</if_yes>
        <if_no>カバレッジを増やすために証拠収集を続行</if_no>
      </decision_tree>
      <example>
        複数のソースからの証拠を組み合わせる
        証拠品質に基づいて信頼度を評価（0-100）
        調査したコードのカバレッジを報告（0-100）
        情報のギャップを特定し文書化
      </example>
    </pattern>
    <pattern name="reproduce">
      <description>問題が再現可能であることを確認</description>
      <decision_tree name="when_to_use">
        <question>これはバグまたは予期しない動作の調査ですか？</question>
        <if_yes>デバッグ前に問題を確認するために再現パターンを適用</if_yes>
        <if_no>分析タスクには他の調査パターンを使用</if_no>
      </decision_tree>
      <example>
        再現するための正確な手順を収集
        環境条件を特定
        一貫性を判断（常に/時々失敗）
      </example>
    </pattern>
    <pattern name="isolate">
      <description>問題のスコープを絞り込む</description>
      <decision_tree name="when_to_use">
        <question>バグは再現可能だが多くのコンポーネントが関与していますか？</question>
        <if_yes>問題のスコープを絞り込むために分離パターンを適用</if_yes>
        <if_no>スコープが明確な場合は調査パターンに進む</if_no>
      </decision_tree>
      <example>
        問題がいつ始まったかを特定（必要に応じてgit bisect）
        無関係なコンポーネントを除去
        最小限の再現ケースを作成
      </example>
    </pattern>
    <pattern name="investigate">
      <description>デバッグのために体系的に証拠を収集</description>
      <decision_tree name="when_to_use">
        <question>問題は再現され分離されましたか？</question>
        <if_yes>デバッグ証拠を収集するために調査パターンを適用</if_yes>
        <if_no>最初に再現と分離パターンを完了</if_no>
      </decision_tree>
      <example>
        エラーメッセージとスタックトレースを調査
        関連するタイムスタンプのログを確認
        コードパス分析にSerenaを使用
        システム全体のデータフローを追跡
      </example>
    </pattern>
    <pattern name="hypothesize">
      <description>仮説を形成しテスト</description>
      <decision_tree name="when_to_use">
        <question>十分なデバッグ証拠を収集しましたか？</question>
        <if_yes>根本原因理論を形成しテストするために仮説パターンを適用</if_yes>
        <if_no>より多くの証拠を収集するために調査パターンを続行</if_no>
      </decision_tree>
      <example>
        考えられる原因をリストアップ
        可能性でランク付け
        各仮説を確認/反証するテストを設計
      </example>
    </pattern>
    <pattern name="fix">
      <description>解決策を実装し検証</description>
      <decision_tree name="when_to_use">
        <question>仮説が根本原因として確認されましたか？</question>
        <if_yes>解決策を実装し検証するために修正パターンを適用</if_yes>
        <if_no>他の理論をテストするために仮説パターンを続行</if_no>
      </decision_tree>
      <example>
        最小限のターゲット変更を行う
        修正が問題を解決することを確認
        リグレッションを確認
        再発防止のためにテストを追加
      </example>
    </pattern>
  </patterns>
  <workflow>
    <phase name="observe">
      <objective>初期観察を収集</objective>
      <step>1. 症状または質問を明確に文書化</step>
      <step>2. 調査の関連するエントリーポイントを特定</step>
      <step>3. 初期仮説を形成</step>
    </phase>
    <phase name="investigate">
      <objective>体系的に証拠を探索</objective>
      <step>1. コードパスを追跡するためにSerenaツールを使用</step>
      <step>2. 症状から原因への証拠チェーンを構築</step>
      <step>3. 仮説を検証または無効化</step>
    </phase>
    <phase name="conclude">
      <objective>証拠に基づく結論を形成</objective>
      <step>1. 発見事項を一貫した説明に統合</step>
      <step>2. 証拠品質に基づいて信頼度を評価</step>
      <step>3. 将来の参照のために文書化</step>
    </phase>
  </workflow>
  <error_escalation>
    <level severity="low">
      <example>証拠の追跡が不完全</example>
      <action>レポートに記載し、続行</action>
    </level>
    <level severity="medium">
      <example>矛盾する証拠が見つかった</example>
      <action>問題を文書化し、AskUserQuestionで明確化を求める</action>
    </level>
    <level severity="high">
      <example>根本原因を特定できない</example>
      <action>停止し、ユーザーに選択肢を提示</action>
    </level>
    <level severity="critical">
      <example>調査でセキュリティ問題が判明</example>
      <action>操作をブロックし、明示的なユーザー確認を要求</action>
    </level>
  </error_escalation>
  <constraints>
    <must>結論の前に証拠チェーンを構築</must>
    <must>具体的なfile:line参照を引用</must>
    <must>信頼度レベルを明示的に記載</must>
    <avoid>証拠のない推測</avoid>
    <avoid>仮説テストにおける確証バイアス</avoid>
    <avoid>代替案を探索せずに結論を出す</avoid>
  </constraints>
  <tools>
    <tool name="mcp__serena__find_symbol">
      <description>コードベース内で名前によって特定のシンボルを検索</description>
      <param name="name_path_pattern">シンボル名にマッチするパターン</param>
      <param name="relative_path">検索を制限するオプションのパス</param>
      <param name="depth">子を取得する深さ（デフォルト0）</param>
      <use_case>クラス、関数、変数の定義を検索</use_case>
    </tool>
    <tool name="mcp__serena__get_symbols_overview">
      <description>ファイルの高レベル構造を取得</description>
      <param name="relative_path">分析するファイルへのパス</param>
      <param name="depth">シンボルツリーの深さ（デフォルト0）</param>
      <use_case>詳細調査前にファイル構成を理解</use_case>
    </tool>
    <tool name="mcp__serena__find_referencing_symbols">
      <description>シンボルへのすべての参照を検索</description>
      <param name="name_path">参照を検索するシンボル</param>
      <param name="relative_path">シンボルを含むファイル</param>
      <use_case>依存関係と使用パターンを追跡</use_case>
    </tool>
    <tool name="mcp__serena__search_for_pattern">
      <description>コードベース全体で正規表現パターンを検索</description>
      <param name="substring_pattern">検索する正規表現</param>
      <param name="relative_path">検索を制限するオプションのパス</param>
      <param name="restrict_search_to_code_files">コードファイルに制限</param>
      <use_case>ファイル全体で特定のパターンまたは使用法を検索</use_case>
    </tool>
  </tools>
  <concepts>
    <concept name="evidence_standards">
      <description>証拠の収集と報告の基準</description>
      <example>
        引用: 常にfile:line参照を提供（path/to/file.ext:line_number）

        信頼度レベル:

        - 90-100: 直接的なコード証拠、明示的なドキュメント
        - 70-89: 複数のソースからの強い推論
        - 50-69: いくつかのギャップを伴う合理的な推論
        - 0-49: 推測、証拠不十分

        カバレッジレベル:

        - 90-100: すべての関連ファイルを調査
        - 70-89: ほとんどの関連ファイルを調査
        - 50-69: 主要ファイルを調査、いくつかのギャップ
        - 0-49: 限定的な調査
      </example>
    </concept>
    <concept name="null_reference">
      <description>ヌルポインタまたは未定義参照エラー</description>
      <example>
        症状: NullPointerException、undefined is not a function
        調査: ヌルアクセスへのすべてのパスを確認
        修正: ヌルチェックを追加または初期化を確保
      </example>
    </concept>
    <concept name="race_condition">
      <description>並行アクセスの問題</description>
      <example>
        症状: 断続的な失敗、時々動作する
        調査: 共有可変状態、非同期操作を探す
        修正: 同期を追加または不変性のために再設計
      </example>
    </concept>
    <concept name="off_by_one">
      <description>境界条件エラー</description>
      <example>
        症状: 最初/最後の要素が欠落、インデックス範囲外
        調査: ループ境界とインデックス計算を確認
        修正: 開始/終了条件を検証、inclusive/exclusiveを正しく使用
      </example>
    </concept>
    <concept name="resource_leak">
      <description>時間とともに蓄積するクローズされていないリソース</description>
      <example>
        症状: メモリ増加、接続枯渇
        調査: リソースの取得と解放パスを確認
        修正: finally/deferでクリーンアップを確保、リソース管理パターンを使用
      </example>
    </concept>
    <concept name="encoding_issue">
      <description>文字エンコーディングの不一致</description>
      <example>
        症状: 文字化けしたテキスト、予期しない文字
        調査: 各変換ステップでエンコーディングを追跡
        修正: パイプライン全体で一貫したエンコーディングを確保
      </example>
    </concept>
    <concept name="five_whys">
      <description>根本原因に到達するまで「なぜ」を繰り返し問う</description>
      <example>
        なぜサーバーがクラッシュしたのか？ - メモリ不足
        なぜメモリ不足なのか？ - 接続プールが枯渇
        なぜ枯渇したのか？ - 接続が解放されていない
        なぜ解放されないのか？ - 例外がクリーンアップをバイパス
        根本原因: 接続解放のためのtry-finallyがない
      </example>
    </concept>
    <concept name="timeline_analysis">
      <description>障害に至るイベントのシーケンスを再構築</description>
      <example>
        ログからタイムスタンプを収集
        イベントを時系列に並べる
        期待される動作からの逸脱を特定
      </example>
    </concept>
    <concept name="investigation_output">
      <description>調査結果の標準フォーマット</description>
      <example>
        <question>確認のために質問を再述</question>
        <investigation>file:line参照付きの証拠に基づく発見事項
        - ソース1: path/to/file.ts:42 - 発見の説明
        - ソース2: path/to/other.ts:15 - 発見の説明</investigation>
        <conclusion>証拠に基づく直接的な回答</conclusion>
        <metrics>
        - 信頼度: 0-100
        - 証拠カバレッジ: 0-100</metrics>
        <recommendations>実装なしの推奨アクション</recommendations>
        <unclear_points>回答を改善する情報のギャップ</unclear_points>
      </example>
    </concept>
    <concept name="debugging_output">
      <description>デバッグ結果の標準フォーマット</description>
      <example>
        <problem_statement>問題の明確な説明</problem_statement>
        <reproduction_steps>再現方法</reproduction_steps>
        <investigation>file:line参照付きで収集した証拠</investigation>
        <root_cause>サポート証拠付きで特定された原因</root_cause>
        <solution>根拠付きの提案修正</solution>
        <verification>修正が機能することを検証する方法</verification>
        <prevention>再発を防ぐ方法</prevention>
      </example>
    </concept>
  </concepts>
  <related_agents>
    <agent name="bug">ユーザーがバグやエラーを報告した場合の根本原因調査に使用</agent>
    <agent name="ask">コードベースのアーキテクチャと実装に関する質問への回答に使用</agent>
    <agent name="execute">調査で実装アプローチが確認された後に委任</agent>
  </related_agents>
  <related_skills>
    <skill name="serena-usage">メモリ操作とシンボルレベルのコードナビゲーションに使用</skill>
    <skill name="execution-workflow">調査後に適切な委任で修正を実装するために使用</skill>
    <skill name="fact-check">外部ドキュメントとライブラリ動作を検証するために使用</skill>
    <skill name="testing-patterns">特定されたバグの修正後にリグレッションテストを追加するために使用</skill>
    <skill name="requirements-definition">調査で不明確な要件が明らかになった場合に使用</skill>
  </related_skills>
  <anti_patterns>
    <avoid name="speculation">
      <description>証拠が不十分な場合に推測したり主張したりする</description>
      <instead>信頼度レベルと情報のギャップを明確に記載、必要に応じて追加コンテキストを要求</instead>
    </avoid>
    <avoid name="confirming_assumptions">
      <description>独立した検証なしにユーザーの仮定を確認</description>
      <instead>コードを調査し証拠を収集して主張を独立して検証</instead>
    </avoid>
    <avoid name="uncited_claims">
      <description>file:line参照なしに主張する</description>
      <instead>path/to/file.ext:line_number形式で発見事項にfile:line引用を常に提供</instead>
    </avoid>
    <avoid name="premature_implementation">
      <description>分析を完了する代わりに修正を実装</description>
      <instead>調査と分析に焦点を当て、実装なしで推奨事項を提供</instead>
    </avoid>
  </anti_patterns>
  <best_practices>
    <practice priority="critical">path/to/file.ext:line_number形式ですべての発見事項にfile:line参照を常に提供</practice>
    <practice priority="critical">すべての調査結果に信頼度とカバレッジのメトリクスを評価</practice>
    <practice priority="critical">解決策を提案する前に調査を完了</practice>
    <practice priority="high">ファイル全体を読む前にSerenaシンボルツールを使用</practice>
    <practice priority="high">仮定を確認するのではなく主張を独立して検証</practice>
    <practice priority="high">情報のギャップと不明確な点を文書化</practice>
    <practice priority="medium">信頼度を高めるために複数のソースを確認</practice>
    <practice priority="medium">体系的なデバッグフェーズを使用（再現、分離、調査、仮説、修正）</practice>
  </best_practices>
</skill>
